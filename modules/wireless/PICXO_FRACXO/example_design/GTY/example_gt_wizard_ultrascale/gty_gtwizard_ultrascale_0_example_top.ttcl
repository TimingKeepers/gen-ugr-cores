<: setFileName "gtwizard_ultrascale_0_example_top" :>
<: setFileExtension ".v" :>
<: set ComponentName [getComponentNameString] :>
<: setOutputDirectory "./example_design/GTY/example_gt_wizard_ultrascale" :>
<: set mode [ get_parameter_property MODE ] :>
//------------------------------------------------------------------------------
//  (c) Copyright 2013-2015 Xilinx, Inc. All rights reserved.
//
//  This file contains confidential and proprietary information
//  of Xilinx, Inc. and is protected under U.S. and
//  international copyright and other intellectual property
//  laws.
//
//  DISCLAIMER
//  This disclaimer is not a license and does not grant any
//  rights to the materials distributed herewith. Except as
//  otherwise provided in a valid license issued to you by
//  Xilinx, and to the maximum extent permitted by applicable
//  law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//  WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//  AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//  BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//  INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//  (2) Xilinx shall not be liable (whether in contract or tort,
//  including negligence, or under any other theory of
//  liability) for any loss or damage of any kind or nature
//  related to, arising under or in connection with these
//  materials, including for any direct, or any indirect,
//  special, incidental, or consequential loss or damage
//  (including loss of data, profits, goodwill, or any type of
//  loss or damage suffered as a result of any action brought
//  by a third party) even if such damage or loss was
//  reasonably foreseeable or Xilinx had been advised of the
//  possibility of the same.
//
//  CRITICAL APPLICATIONS
//  Xilinx products are not designed or intended to be fail-
//  safe, or for use in any application requiring fail-safe
//  performance, such as life-support or safety devices or
//  systems, Class III medical devices, nuclear facilities,
//  applications related to the deployment of airbags, or any
//  other applications that could lead to death, personal
//  injury, or severe property or environmental damage
//  (individually and collectively, "Critical
//  Applications"). Customer assumes the sole risk and
//  liability of any use of Xilinx products in Critical
//  Applications, subject only to applicable laws and
//  regulations governing limitations on product liability.
//
//  THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//  PART OF THIS FILE AT ALL TIMES.
//------------------------------------------------------------------------------
// Timestamp : v25_0 @ Fri Apr  8 11:26:58 +0100 2016 Rev: 815:817

`timescale 1ps/1ps

// =====================================================================================================================
// This example design top module instantiates the example design wrapper; slices vectored ports for per-channel
// assignment; and instantiates example resources such as buffers, pattern generators, and pattern checkers for core
// demonstration purposes
// =====================================================================================================================

module gtwizard_ultrascale_0_example_top (

  // Differential reference clock inputs
  input  wire mgtrefclk0_x0y1_p,
  input  wire mgtrefclk0_x0y1_n,

  // Serial data ports for transceiver channel 0
  input  wire ch0_gtyrxn_in,
  input  wire ch0_gtyrxp_in,
  output wire ch0_gtytxn_out,
  output wire ch0_gtytxp_out,

  // User-provided ports for reset helper block(s)
  //  input  wire hb_gtwiz_reset_clk_freerun_in,
  input  wire hb_gtwiz_reset_clk_freerun_in_p,
  input  wire hb_gtwiz_reset_clk_freerun_in_n,
  input  wire hb_gtwiz_reset_all_in,

  // PRBS-based link status ports
  input  wire link_down_latched_reset_in,
  output wire link_status_out,
  output reg  link_down_latched_out = 1'b1

);


  // ===================================================================================================================
  // PER-CHANNEL SIGNAL ASSIGNMENTS
  // ===================================================================================================================

  // The core and example design wrapper vectorize ports across all enabled transceiver channel and common instances for
  // simplicity and compactness. This example design top module assigns slices of each vector to individual, per-channel
  // signal vectors for use if desired. Signals which connect to helper blocks are prefixed "hb#", signals which connect
  // to transceiver common primitives are prefixed "cm#", and signals which connect to transceiver channel primitives
  // are prefixed "ch#", where "#" is the sequential resource number.

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtyrxn_int;
  assign gtyrxn_int[0:0] = ch0_gtyrxn_in;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtyrxp_int;
  assign gtyrxp_int[0:0] = ch0_gtyrxp_in;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtytxn_int;
  assign ch0_gtytxn_out = gtytxn_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtytxp_int;
  assign ch0_gtytxp_out = gtytxp_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_tx_reset_int;
  wire [0:0] hb0_gtwiz_userclk_tx_reset_int;
  assign gtwiz_userclk_tx_reset_int[0:0] = hb0_gtwiz_userclk_tx_reset_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_tx_srcclk_int;
  wire [0:0] hb0_gtwiz_userclk_tx_srcclk_int;
  assign hb0_gtwiz_userclk_tx_srcclk_int = gtwiz_userclk_tx_srcclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_tx_usrclk_int;
  wire [0:0] hb0_gtwiz_userclk_tx_usrclk_int;
  assign hb0_gtwiz_userclk_tx_usrclk_int = gtwiz_userclk_tx_usrclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_tx_usrclk2_int;
  wire [0:0] hb0_gtwiz_userclk_tx_usrclk2_int;
  assign hb0_gtwiz_userclk_tx_usrclk2_int = gtwiz_userclk_tx_usrclk2_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_tx_active_int;
  wire [0:0] hb0_gtwiz_userclk_tx_active_int;
  assign hb0_gtwiz_userclk_tx_active_int = gtwiz_userclk_tx_active_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_rx_reset_int;
  wire [0:0] hb0_gtwiz_userclk_rx_reset_int;
  assign gtwiz_userclk_rx_reset_int[0:0] = hb0_gtwiz_userclk_rx_reset_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_rx_srcclk_int;
  wire [0:0] hb0_gtwiz_userclk_rx_srcclk_int;
  assign hb0_gtwiz_userclk_rx_srcclk_int = gtwiz_userclk_rx_srcclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_rx_usrclk_int;
  wire [0:0] hb0_gtwiz_userclk_rx_usrclk_int;
  assign hb0_gtwiz_userclk_rx_usrclk_int = gtwiz_userclk_rx_usrclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_rx_usrclk2_int;
  wire [0:0] hb0_gtwiz_userclk_rx_usrclk2_int;
  assign hb0_gtwiz_userclk_rx_usrclk2_int = gtwiz_userclk_rx_usrclk2_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_userclk_rx_active_int;
  wire [0:0] hb0_gtwiz_userclk_rx_active_int;
  assign hb0_gtwiz_userclk_rx_active_int = gtwiz_userclk_rx_active_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_clk_freerun_int;
  wire [0:0] hb0_gtwiz_reset_clk_freerun_int = 1'b0;
  assign gtwiz_reset_clk_freerun_int[0:0] = hb0_gtwiz_reset_clk_freerun_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_all_int;
  wire [0:0] hb0_gtwiz_reset_all_int = 1'b0;
  assign gtwiz_reset_all_int[0:0] = hb0_gtwiz_reset_all_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_tx_pll_and_datapath_int;
  wire [0:0] hb0_gtwiz_reset_tx_pll_and_datapath_int;
  assign gtwiz_reset_tx_pll_and_datapath_int[0:0] = hb0_gtwiz_reset_tx_pll_and_datapath_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_tx_datapath_int;
  wire [0:0] hb0_gtwiz_reset_tx_datapath_int;
  assign gtwiz_reset_tx_datapath_int[0:0] = hb0_gtwiz_reset_tx_datapath_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_rx_pll_and_datapath_int;
  wire [0:0] hb0_gtwiz_reset_rx_pll_and_datapath_int = 1'b0;
  assign gtwiz_reset_rx_pll_and_datapath_int[0:0] = hb0_gtwiz_reset_rx_pll_and_datapath_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_rx_datapath_int;
  wire [0:0] hb0_gtwiz_reset_rx_datapath_int = 1'b0;
  assign gtwiz_reset_rx_datapath_int[0:0] = hb0_gtwiz_reset_rx_datapath_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_rx_cdr_stable_int;
  wire [0:0] hb0_gtwiz_reset_rx_cdr_stable_int;
  assign hb0_gtwiz_reset_rx_cdr_stable_int = gtwiz_reset_rx_cdr_stable_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_tx_done_int;
  wire [0:0] hb0_gtwiz_reset_tx_done_int;
  assign hb0_gtwiz_reset_tx_done_int = gtwiz_reset_tx_done_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtwiz_reset_rx_done_int;
  wire [0:0] hb0_gtwiz_reset_rx_done_int;
  assign hb0_gtwiz_reset_rx_done_int = gtwiz_reset_rx_done_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [31:0] gtwiz_userdata_tx_int;
  wire [31:0] hb0_gtwiz_userdata_tx_int;
  assign gtwiz_userdata_tx_int[31:0] = hb0_gtwiz_userdata_rx_int; //for picxo and fracxo example, we loopback the rx data on tx

  //--------------------------------------------------------------------------------------------------------------------
  wire [31:0] gtwiz_userdata_rx_int;
  wire [31:0] hb0_gtwiz_userdata_rx_int;
  assign hb0_gtwiz_userdata_rx_int = gtwiz_userdata_rx_int[31:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] gtrefclk00_int;
  wire [0:0] cm0_gtrefclk00_int;
  assign gtrefclk00_int[0:0] = cm0_gtrefclk00_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] qpll0outclk_int;
  wire [0:0] cm0_qpll0outclk_int;
  assign cm0_qpll0outclk_int = qpll0outclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] qpll0outrefclk_int;
  wire [0:0] cm0_qpll0outrefclk_int;
  assign cm0_qpll0outrefclk_int = qpll0outrefclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] qpll1outclk_int;
  wire [0:0] cm0_qpll1outclk_int;
  assign cm0_qpll1outclk_int = qpll1outclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] qpll1outrefclk_int;
  wire [0:0] cm0_qpll1outrefclk_int;
  assign cm0_qpll1outrefclk_int = qpll1outrefclk_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [4:0] txdiffctrl_int;
  //  wire [4:0] ch0_txdiffctrl_int = 5'b11000; Controlled via VIO for PICXO
  //assign txdiffctrl_int[4:0] = ch0_txdiffctrl_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] txpippmen_int;
<: if { $mode == "PICXO"} { :> 
  wire [0:0] ch0_txpippmen_int = 1'b1; // picxo: enable TXPI
<: } elseif { $mode == "FRACXO" } { :>
  wire [0:0] ch0_txpippmen_int = 1'b0;
<: } :>  
  assign txpippmen_int[0:0] = ch0_txpippmen_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] txpippmovrden_int;
  wire [0:0] ch0_txpippmovrden_int = 1'b0;
  assign txpippmovrden_int[0:0] = ch0_txpippmovrden_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] txpippmpd_int;
  wire [0:0] ch0_txpippmpd_int = 1'b0;
  assign txpippmpd_int[0:0] = ch0_txpippmpd_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] txpippmsel_int;
  wire [0:0] ch0_txpippmsel_int = 1'b1;
  assign txpippmsel_int[0:0] = ch0_txpippmsel_int;

  //--------------------------------------------------------------------------------------------------------------------
  wire [4:0] txpippmstepsize_int;
  wire [4:0] ch0_txpippmstepsize_int = 5'b00000;
<: if { $mode == "PICXO"} { :> 
  //assign txpippmstepsize_int[4:0] = ch0_txpippmstepsize_int; //picxo: this is controlled by the picxo
<: } elseif {$mode == "FRACXO"} { :>
  assign txpippmstepsize_int[4:0] = ch0_txpippmstepsize_int; 
<: } :>  
  
  //--------------------------------------------------------------------------------------------------------------------
  wire [4:0] txpostcursor_int;
  // This vector is not sliced because it is directly assigned in a debug core instance below

  //--------------------------------------------------------------------------------------------------------------------
  wire [4:0] txprecursor_int;
  // This vector is not sliced because it is directly assigned in a debug core instance below

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] rxpmaresetdone_int;
  wire [0:0] ch0_rxpmaresetdone_int;
  assign ch0_rxpmaresetdone_int = rxpmaresetdone_int[0:0];

  //--------------------------------------------------------------------------------------------------------------------
  wire [0:0] txpmaresetdone_int;
  wire [0:0] ch0_txpmaresetdone_int;
  assign ch0_txpmaresetdone_int = txpmaresetdone_int[0:0];


  // ===================================================================================================================
  // BUFFERS
  // ===================================================================================================================

  // Buffer the hb_gtwiz_reset_all_in input and logically combine it with the internal signal from the example
  // initialization block as well as the VIO-sourced reset
  wire hb_gtwiz_reset_all_vio_int;
  wire hb_gtwiz_reset_all_buf_int;
  wire hb_gtwiz_reset_all_init_int;
  wire hb_gtwiz_reset_all_int;

  IBUF ibuf_hb_gtwiz_reset_all_inst (
    .I (hb_gtwiz_reset_all_in),
    .O (hb_gtwiz_reset_all_buf_int)
  );

  assign hb_gtwiz_reset_all_int = hb_gtwiz_reset_all_buf_int || hb_gtwiz_reset_all_init_int || hb_gtwiz_reset_all_vio_int;

  // Globally buffer the free-running input clock
  wire hb_gtwiz_reset_clk_freerun_buf_int;
  wire hb_gtwiz_reset_clk_freerun_in;

  IBUFDS ibuf_hb_gt_wiz_free_run (
  .I (hb_gtwiz_reset_clk_freerun_in_p),
  .IB (hb_gtwiz_reset_clk_freerun_in_n),
  .O (hb_gtwiz_reset_clk_freerun_in)
  );


  BUFG bufg_clk_freerun_inst (
    .I (hb_gtwiz_reset_clk_freerun_in),
    .O (hb_gtwiz_reset_clk_freerun_buf_int)
  );

  // Instantiate a differential reference clock buffer for each reference clock differential pair in this configuration,
  // and assign the single-ended output of each differential reference clock buffer to the appropriate PLL input signal

  // Differential reference clock buffer for MGTREFCLK0_X0Y1
  wire mgtrefclk0_x0y1_int;

  IBUFDS_GTE3 #(
    .REFCLK_EN_TX_PATH  (1'b0),
    .REFCLK_HROW_CK_SEL (2'b00),
    .REFCLK_ICNTL_RX    (2'b00)
  ) IBUFDS_GTE3_MGTREFCLK0_X0Y1_INST (
    .I     (mgtrefclk0_x0y1_p),
    .IB    (mgtrefclk0_x0y1_n),
    .CEB   (1'b0),
    .O     (mgtrefclk0_x0y1_int),
    .ODIV2 ()
  );

  assign cm0_gtrefclk00_int = mgtrefclk0_x0y1_int;


  // ===================================================================================================================
  // USER CLOCKING RESETS
  // ===================================================================================================================

  // The TX user clocking helper block should be held in reset until the clock source of that block is known to be
  // stable. The following assignment is an example of how that stability can be determined, based on the selected TX
  // user clock source. Replace the assignment with the appropriate signal or logic to achieve that behavior as needed.
  assign hb0_gtwiz_userclk_tx_reset_int = ~(&txpmaresetdone_int);

  // The RX user clocking helper block should be held in reset until the clock source of that block is known to be
  // stable. The following assignment is an example of how that stability can be determined, based on the selected RX
  // user clock source. Replace the assignment with the appropriate signal or logic to achieve that behavior as needed.
  assign hb0_gtwiz_userclk_rx_reset_int = ~(&rxpmaresetdone_int);


  // ===================================================================================================================
  // PRBS STIMULUS, CHECKING, AND LINK MANAGEMENT
  // ===================================================================================================================

  // PRBS stimulus
  // -------------------------------------------------------------------------------------------------------------------

  // PRBS-based data stimulus module for transceiver channel 0
  //PICXO remove PRBS generator because we loopback the RX data to TX.  
  /*(* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_stimulus_raw example_stimulus_inst0 (
    .gtwiz_reset_all_in          (hb_gtwiz_reset_all_int),
    .gtwiz_userclk_tx_usrclk2_in (hb0_gtwiz_userclk_tx_usrclk2_int),
    .gtwiz_userclk_tx_active_in  (hb0_gtwiz_userclk_tx_active_int),
    .txdata_out                  (hb0_gtwiz_userdata_tx_int)
  );
*/
  // PRBS checking
  // -------------------------------------------------------------------------------------------------------------------

  // Declare a signal vector of PRBS match indicators, with one indicator bit per transceiver channel
  wire [0:0] prbs_match_int;

  // PRBS-based data checking module for transceiver channel 0
  gtwizard_ultrascale_0_example_checking_raw example_checking_inst0 (
    .gtwiz_reset_all_in          (hb_gtwiz_reset_all_int || ~hb0_gtwiz_reset_rx_done_int ),
    .gtwiz_userclk_rx_usrclk2_in (hb0_gtwiz_userclk_rx_usrclk2_int),
    .gtwiz_userclk_rx_active_in  (hb0_gtwiz_userclk_rx_active_int),
    .rxdata_in                   (hb0_gtwiz_userdata_rx_int),
    .prbs_match_out              (prbs_match_int[0])
  );

  // PRBS match and related link management
  // -------------------------------------------------------------------------------------------------------------------

  // Perform a bitwise NAND of all PRBS match indicators, creating a combinatorial indication of any PRBS mismatch
  // across all transceiver channels
  wire prbs_error_any_async = ~(&prbs_match_int);
  wire prbs_error_any_sync;

  // Synchronize the PRBS mismatch indicator the free-running clock domain, using a reset synchronizer with asynchronous
  // reset and synchronous removal
  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_reset_synchronizer reset_synchronizer_prbs_match_all_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .rst_in (prbs_error_any_async),
    .rst_out(prbs_error_any_sync)
  );

  // Implement an example link status state machine using a simple leaky bucket mechanism. The link status indicates
  // the continual PRBS match status to both the top-level observer and the initialization state machine, while being
  // tolerant of occasional bit errors. This is an example and can be modified as necessary.
  localparam ST_LINK_DOWN = 1'b0;
  localparam ST_LINK_UP   = 1'b1;
  reg        sm_link      = ST_LINK_DOWN;
  reg [6:0]  link_ctr     = 7'd0;

  always @(posedge hb_gtwiz_reset_clk_freerun_buf_int) begin
    case (sm_link)
      // The link is considered to be down when the link counter initially has a value less than 67. When the link is
      // down, the counter is incremented on each cycle where all PRBS bits match, but reset whenever any PRBS mismatch
      // occurs. When the link counter reaches 67, transition to the link up state.
      ST_LINK_DOWN: begin
        if (prbs_error_any_sync !== 1'b0) begin
          link_ctr <= 7'd0;
        end
        else begin
          if (link_ctr < 7'd67)
            link_ctr <= link_ctr + 7'd1;
          else
            sm_link <= ST_LINK_UP;
        end
      end

      // When the link is up, the link counter is decreased by 34 whenever any PRBS mismatch occurs, but is increased by
      // only 1 on each cycle where all PRBS bits match, up to its saturation point of 67. If the link counter reaches
      // 0 (including rollover protection), transition to the link down state.
      ST_LINK_UP: begin
        if (prbs_error_any_sync !== 1'b0) begin
          if (link_ctr > 7'd33) begin
            link_ctr <= link_ctr - 7'd34;
            if (link_ctr == 7'd34)
              sm_link  <= ST_LINK_DOWN;
          end
          else begin
            link_ctr <= 7'd0;
            sm_link  <= ST_LINK_DOWN;
          end
        end
        else begin
          if (link_ctr < 7'd67)
            link_ctr <= link_ctr + 7'd1;
        end
      end
    endcase
  end

  // Synchronize the latched link down reset input and the VIO-driven signal into the free-running clock domain
  wire link_down_latched_reset_vio_int;
  wire link_down_latched_reset_sync;

  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_bit_synchronizer bit_synchronizer_link_down_latched_reset_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .i_in   (link_down_latched_reset_in || link_down_latched_reset_vio_int),
    .o_out  (link_down_latched_reset_sync)
  );

  // Reset the latched link down indicator when the synchronized latched link down reset signal is high. Otherwise, set
  // the latched link down indicator upon losing link. This indicator is available for user reference.
  always @(posedge hb_gtwiz_reset_clk_freerun_buf_int) begin
    if (link_down_latched_reset_sync)
      link_down_latched_out <= 1'b0;
    else if (!sm_link)
      link_down_latched_out <= 1'b1;
  end

  // Assign the link status indicator to the top-level two-state output for user reference
  assign link_status_out = sm_link;


  // ===================================================================================================================
  // INITIALIZATION
  // ===================================================================================================================

  // Declare the receiver reset signals that interface to the reset controller helper block. For this configuration,
  // which uses the same PLL type for transmitter and receiver, the "reset RX PLL and datapath" feature is not used.
  wire hb_gtwiz_reset_rx_pll_and_datapath_int = 1'b0;
  wire hb_gtwiz_reset_rx_datapath_int;

  // Declare signals which connect the VIO instance to the initialization module for debug purposes
  wire       init_done_int;
  wire [3:0] init_retry_ctr_int;

  // Combine the receiver reset signals form the initialization module and the VIO to drive the appropriate reset
  // controller helper block reset input
  wire hb_gtwiz_reset_rx_pll_and_datapath_vio_int;
  wire hb_gtwiz_reset_rx_datapath_vio_int;
  wire hb_gtwiz_reset_rx_datapath_init_int;

  assign hb_gtwiz_reset_rx_datapath_int = hb_gtwiz_reset_rx_datapath_init_int || hb_gtwiz_reset_rx_datapath_vio_int;

  // The example initialization module interacts with the reset controller helper block and other example design logic
  // to retry failed reset attempts in order to mitigate bring-up issues such as initially-unavilable reference clocks
  // or data connections. It also resets the receiver in the event of link loss in an attempt to regain link, so please
  // note the possibility that this behavior can have the effect of overriding or disturbing user-provided inputs that
  // destabilize the data stream. It is a demonstration only and can be modified to suit your system needs.
  gtwizard_ultrascale_0_example_init example_init_inst (
    .clk_freerun_in  (hb_gtwiz_reset_clk_freerun_buf_int),
    .reset_all_in    (hb_gtwiz_reset_all_int),
    .tx_init_done_in (gtwiz_reset_tx_done_int),
    .rx_init_done_in (gtwiz_reset_rx_done_int),
    .rx_data_good_in (1'b1),  //picxo is loopback, we do not compare data received to the data transmitted.
    .reset_all_out   (hb_gtwiz_reset_all_init_int),
    .reset_rx_out    (), //PICXO, we do not reset the transceiver
    .init_done_out   (init_done_int),
    .retry_ctr_out   (init_retry_ctr_int)
  );


  // ===================================================================================================================
  // VIO FOR HARDWARE BRING-UP AND DEBUG
  // ===================================================================================================================

  // Synchronize txpmaresetdone into the free-running clock domain for VIO usage
  wire [0:0] txpmaresetdone_vio_sync;

  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_bit_synchronizer bit_synchronizer_vio_txpmaresetdone_0_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .i_in   (txpmaresetdone_int[0]),
    .o_out  (txpmaresetdone_vio_sync[0])
  );

  // Synchronize rxpmaresetdone into the free-running clock domain for VIO usage
  wire [0:0] rxpmaresetdone_vio_sync;

  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_bit_synchronizer bit_synchronizer_vio_rxpmaresetdone_0_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .i_in   (rxpmaresetdone_int[0]),
    .o_out  (rxpmaresetdone_vio_sync[0])
  );

  // Synchronize gtwiz_reset_tx_done into the free-running clock domain for VIO usage
  wire [0:0] gtwiz_reset_tx_done_vio_sync;

  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_bit_synchronizer bit_synchronizer_vio_gtwiz_reset_tx_done_0_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .i_in   (gtwiz_reset_tx_done_int[0]),
    .o_out  (gtwiz_reset_tx_done_vio_sync[0])
  );

  // Synchronize gtwiz_reset_rx_done into the free-running clock domain for VIO usage
  wire [0:0] gtwiz_reset_rx_done_vio_sync;

  (* DONT_TOUCH = "TRUE" *)
  gtwizard_ultrascale_0_example_bit_synchronizer bit_synchronizer_vio_gtwiz_reset_rx_done_0_inst (
    .clk_in (hb_gtwiz_reset_clk_freerun_buf_int),
    .i_in   (gtwiz_reset_rx_done_int[0]),
    .o_out  (gtwiz_reset_rx_done_vio_sync[0])
  );


  // Instantiate the VIO IP core for hardware bring-up and debug purposes, connecting relevant debug and analysis
  // signals which have been enabled during Wizard IP customization. This initial set of connected signals is
  // provided as a convenience and example, but more or fewer ports can be used as needed; simply re-customize and
  // re-generate the VIO instance, then connect any exposed signals that are needed. Signals which are synchronous to
  // clocks other than the free-running clock will require synchronization. For usage, refer to Vivado Design Suite
  // User Guide: Programming and Debugging (UG908)
  gtwizard_ultrascale_0_vio_0 gtwizard_ultrascale_0_vio_0_inst (
    .clk (hb_gtwiz_reset_clk_freerun_buf_int)
    ,.probe_in0 (link_status_out)
    ,.probe_in1 (link_down_latched_out)
    ,.probe_in2 (init_done_int)
    ,.probe_in3 (init_retry_ctr_int)
    ,.probe_in4 (txpmaresetdone_vio_sync)
    ,.probe_in5 (rxpmaresetdone_vio_sync)
    ,.probe_in6 (gtwiz_reset_tx_done_vio_sync)
    ,.probe_in7 (gtwiz_reset_rx_done_vio_sync)
    ,.probe_out0 (hb_gtwiz_reset_all_vio_int)
    ,.probe_out1 (hb0_gtwiz_reset_tx_pll_and_datapath_int)
    ,.probe_out2 (hb0_gtwiz_reset_tx_datapath_int)
    ,.probe_out3 (hb_gtwiz_reset_rx_pll_and_datapath_vio_int)
    ,.probe_out4 (hb_gtwiz_reset_rx_datapath_vio_int)
    ,.probe_out5 (link_down_latched_reset_vio_int)
    ,.probe_out6 (txdiffctrl_int  )
    ,.probe_out7 (txpostcursor_int)
    ,.probe_out8 (txprecursor_int )
  );


  // ===================================================================================================================
  // EXAMPLE WRAPPER INSTANCE
  // ===================================================================================================================
  <: if {$mode == "FRACXO"} { :>
  wire [24:0] sdm0data          ;
  wire [0:0]  sdm0reset         ;
  wire [1:0]  sdm0width = 2'b00 ;
  wire [24:0] sdm1data          ;
  wire [0:0]  sdm1reset         ;
  wire [1:0]  sdm1width         ;
   <: } :>   
  // Instantiate the example design wrapper, mapping its enabled ports to per-channel internal signals and example
  // resources as appropriate
  gtwizard_ultrascale_0_example_wrapper example_wrapper_inst (
    .gtyrxn_in                               (gtyrxn_int)
   ,.gtyrxp_in                               (gtyrxp_int)
   ,.gtytxn_out                              (gtytxn_int)
   ,.gtytxp_out                              (gtytxp_int)
   ,.gtwiz_userclk_tx_reset_in               (gtwiz_userclk_tx_reset_int)
   ,.gtwiz_userclk_tx_srcclk_out             (gtwiz_userclk_tx_srcclk_int)
   ,.gtwiz_userclk_tx_usrclk_out             (gtwiz_userclk_tx_usrclk_int)
   ,.gtwiz_userclk_tx_usrclk2_out            (gtwiz_userclk_tx_usrclk2_int)
   ,.gtwiz_userclk_tx_active_out             (gtwiz_userclk_tx_active_int)
   ,.gtwiz_userclk_rx_reset_in               (gtwiz_userclk_rx_reset_int)
   ,.gtwiz_userclk_rx_srcclk_out             (gtwiz_userclk_rx_srcclk_int)
   ,.gtwiz_userclk_rx_usrclk_out             (gtwiz_userclk_rx_usrclk_int)
   ,.gtwiz_userclk_rx_usrclk2_out            (gtwiz_userclk_rx_usrclk2_int)
   ,.gtwiz_userclk_rx_active_out             (gtwiz_userclk_rx_active_int)
   ,.gtwiz_reset_clk_freerun_in              ({1{hb_gtwiz_reset_clk_freerun_buf_int}})
   ,.gtwiz_reset_all_in                      ({1{hb_gtwiz_reset_all_int}})
   ,.gtwiz_reset_tx_pll_and_datapath_in      (gtwiz_reset_tx_pll_and_datapath_int)
   ,.gtwiz_reset_tx_datapath_in              (gtwiz_reset_tx_datapath_int)
   ,.gtwiz_reset_rx_pll_and_datapath_in      ({1{hb_gtwiz_reset_rx_pll_and_datapath_int}})
   ,.gtwiz_reset_rx_datapath_in              ({1{hb_gtwiz_reset_rx_datapath_int}})
   ,.gtwiz_reset_rx_cdr_stable_out           (gtwiz_reset_rx_cdr_stable_int)
   ,.gtwiz_reset_tx_done_out                 (gtwiz_reset_tx_done_int)
   ,.gtwiz_reset_rx_done_out                 (gtwiz_reset_rx_done_int)
   ,.gtwiz_userdata_tx_in                    (gtwiz_userdata_tx_int)
   ,.gtwiz_userdata_rx_out                   (gtwiz_userdata_rx_int)
   ,.gtrefclk00_in                           (gtrefclk00_int)
   ,.qpll0outclk_out                         (qpll0outclk_int)
   ,.qpll0outrefclk_out                      (qpll0outrefclk_int)
   ,.txdiffctrl_in                           (txdiffctrl_int)
<: if {$mode == "PICXO"} { :>
   ,.txpippmen_in                            (txpippmen_int)
   ,.txpippmovrden_in                        (txpippmovrden_int)
   ,.txpippmpd_in                            (txpippmpd_int)
   ,.txpippmsel_in                           (txpippmsel_int)
   ,.txpippmstepsize_in                      (txpippmstepsize_int)
<: } :>
   ,.txpostcursor_in                         (txpostcursor_int)
   ,.txprecursor_in                          (txprecursor_int)
   ,.rxpmaresetdone_out                      (rxpmaresetdone_int)
   ,.txpmaresetdone_out                      (txpmaresetdone_int)
<: if {$mode == "FRACXO"} { :>
   ,.sdm0data_in                             (sdm0data  )
   ,.sdm0reset_in                            (sdm0reset )
   ,.sdm0width_in                            (sdm0width )
<: } :>   
);

reg  [7:0]  picxo_rst       ;
wire [4:0]  G1              ;
wire [4:0]  G2              ;
wire [15:0] R               ;
wire [15:0] V               ;
wire [3:0]  acc_step        ;
wire [15:0] ce_dsp_rate     ;
wire [21:0] Offset_ppm      ;
wire        Offset_en       ;
wire        hold            ;
wire [0:0]  don             ;
wire        picxo_rst_in    ;
wire [6:0]  C = 7'b0        ;
wire [9:0]  P = 10'b0       ;
wire [9:0]  N = 10'b0       ;
wire [20:0] error           ;
wire [21:0] volt            ;        
wire        ce_pi           ; 
wire        ce_pi2          ; 
wire        ce_dsp          ; 
wire        ovf_pd          ; 
wire        ovf_ab          ; 
wire        ovf_volt        ; 
wire        ovf_int         ; 
wire [5:0]  sdm_coarse      ; 


always@(posedge gtwiz_userclk_tx_usrclk2_int, posedge picxo_rst_in, negedge gtwiz_reset_tx_done_int)
begin
   if (picxo_rst_in | ~gtwiz_reset_tx_done_int ) begin
        picxo_rst[7:0]     <= 8'b11111111;
   end
   else begin
        picxo_rst[7:0]     <=  {picxo_rst[6:0],picxo_rst_in};
   end
end 
  
  picxo_vio picxo_vio_i (
    .clk            ( gtwiz_userclk_tx_usrclk2_int  ),
    .probe_out0     ( G1              ),
    .probe_out1     ( G2              ),
    .probe_out2     ( R               ),
    .probe_out3     ( V               ),
    .probe_out4     ( acc_step        ),
    .probe_out5     ( ce_dsp_rate     ),
    .probe_out6     ( Offset_ppm      ),
    .probe_out7     ( Offset_en       ),
    .probe_out8     ( hold            ),
    .probe_out9     ( picxo_rst_in    ),
<: if {$mode == "FRACXO"} { :>
    .probe_out10    ( sdm_coarse      ),
<: } else { :>
    .probe_out10    (                 ),    
<: } :>
    .probe_out11    ( don             )
  );                                

  
picxo_ila picxo_ila_i (
    .clk        ( gtwiz_userclk_tx_usrclk2_int ),
    .probe0     ( error                        ),
    .probe1     ( volt                         ),
    .probe2     ( 8'b0                         ),
    .probe3     ( ce_pi                        ),
    .probe4     ( ce_pi2                       ),
    .probe5     ( ce_dsp                       ), 
    .probe6     ( ovf_pd                       ), 
    .probe7     ( ovf_ab                       ),
    .probe8     ( ovf_volt                     ),
    .probe9     ( ovf_int                      )
  );       
<: if {$mode == "PICXO"} { :>
  <=: $ComponentName :> <=: $ComponentName :>_i  (
          .REF_CLK_I        ( gtwiz_userclk_rx_usrclk2_int  ),
          .RESET_I          ( picxo_rst[7]                  ),
          .DRPEN_O          (                               ),
          .DRPWEN_O         (                               ),
          .DRPRDY_I         ( 1'b0                          ),
          .DRPDO_I          ( 16'h0000                      ),
          .DRPDATA_O        (                               ),
          .DRPADDR_O        (                               ),
          .DRPBUSY_O        (                               ),
          .TXOUTCLK_I       ( gtwiz_userclk_tx_usrclk2_int  ),
          .RSIGCE_I         ( 1'b1                          ),
          .VSIGCE_I         ( 1'b1                          ),
          .VSIGCE_O         (                               ),
          .ACC_STEP         ( acc_step                      ),
          .G1               ( G1                            ),
          .G2               ( G2                            ),
          .R                ( R                             ),
          .V                ( V                             ),
          .C_I              ( C                             ),
          .P_I              ( P                             ),
          .N_I              ( N                             ),
          .DON_I            ( don                           ),
          .OFFSET_PPM       ( Offset_ppm                    ),
          .OFFSET_EN        ( Offset_en                     ),
          .HOLD             ( hold                          ),
          .CE_DSP_RATE      ( ce_dsp_rate                   ),
           //DRP USER PORT
          .DRP_USER_REQ_I   ( 1'b0                          ),
          .DRP_USER_DONE_I  ( 1'b0                          ),
          .DRPEN_USER_I     ( 1'b0                          ),
          .DRPWEN_USER_I    ( 1'b0                          ),
          .DRPDATA_USER_I   ( 16'b0                         ),
          .DRPDATA_USER_O   (                               ),
          .DRPADDR_USER_I   ( 9'b0                          ),
          .DRPRDY_USER_O    (                               ),
          .ACC_DATA         ( txpippmstepsize_int           ),
          //DEBUG PORT
          .ERROR_O          ( error                         ),
          .VOLT_O           ( volt                          ),
          .DRPDATA_SHORT_O  (                               ),
          .CE_PI_O          ( ce_pi                         ),
          .CE_PI2_O         ( ce_pi2                        ),
          .CE_DSP_O         ( ce_dsp                        ),
          .OVF_PD           ( ovf_pd                        ),
          .OVF_AB           ( ovf_ab                        ),
          .OVF_VOLT         ( ovf_volt                      ),
          .OVF_INT          ( ovf_int                       )
        );      

<: } else { :>
assign SDM0RESET = picxo_rst[7];


  <=: $ComponentName :> <=: $ComponentName :>_i  (
          .REF_CLK_I        ( gtwiz_userclk_rx_usrclk2_int  ),
          .RESET_I          ( picxo_rst[7]                  ),
          .TXOUTCLK_I       ( gtwiz_userclk_tx_usrclk2_int  ),
          .RSIGCE_I         ( 1'b1                          ),
          .VSIGCE_I         ( 1'b1                          ),
          .VSIGCE_O         (                               ),
          .G1               ( G1                            ),
          .G2               ( G2                            ),
          .R                ( R                             ),
          .V                ( V                             ),
          .C_I              ( C                             ),
          .P_I              ( P                             ),
          .N_I              ( N                             ),
          .DON_I            ( don                           ),
          .OFFSET_PPM       ( Offset_ppm                    ),
          .OFFSET_EN        ( Offset_en                     ),
          .HOLD             ( hold                          ),
          .CE_DSP_RATE      ( ce_dsp_rate                   ),
          //FRACXO 
          .SDM_COARSE_I     ( sdm_coarse                    ), 
          .SDM_DATA_O       ( sdm0data                      ), 
          //DEBUG PORT
          .ERROR_O          ( error                         ),
          .VOLT_O           ( volt                          ),
          .CE_PI_O          ( ce_pi                         ),
          .CE_PI2_O         ( ce_pi2                        ),
          .CE_DSP_O         ( ce_dsp                        ),
          .OVF_PD           ( ovf_pd                        ),
          .OVF_AB           ( ovf_ab                        ),
          .OVF_VOLT         ( ovf_volt                      ),
          .OVF_INT          ( ovf_int                       )
        ); 
<: } :> 
        
endmodule










